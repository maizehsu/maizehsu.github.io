<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maize&#39;s Blog</title>
  
  
  <link href="https://maizehsu.me/atom.xml" rel="self"/>
  
  <link href="https://maizehsu.me/"/>
  <updated>2022-08-15T10:52:09.557Z</updated>
  <id>https://maizehsu.me/</id>
  
  <author>
    <name>Maize_hsu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随记：于 2020.12 考完托福后</title>
    <link href="https://maizehsu.me/2022/08/15/TOEFL/"/>
    <id>https://maizehsu.me/2022/08/15/TOEFL/</id>
    <published>2022-08-15T10:19:44.858Z</published>
    <updated>2022-08-15T10:52:09.557Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浅聊"><a href="#浅聊" class="headerlink" title="浅聊"></a>浅聊</h4><p>客观评价来说，托福难度不高。考前刷过少许题目之后身边的小伙伴们都能做到阅读听力接近满分。那么，决定高分的部分是写作和口语。然而，写作和口语多是机器阅卷，所以掌握适当技巧，结合自己本身还不错的英语底子，高分便不难拿。不过，私以为在申请过程中，只要不申请“贵族学校”，如部分藤校，文理学院等，一般的学校，tech 类尤甚，对于语言考试的要求仅仅是过线而已。所以，有空余时间的话大可多做些自己喜欢的事情，卷卷绩点，跟朋友 hang out。这里给一个简单的参考线，103 + 合格，105 + 很棒，108 + 超群，110 + 浪费。</p><p>下面简单聊聊每个部分的考试形式和应试技巧。</p><h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><h6 id="前三个task"><a href="#前三个task" class="headerlink" title="前三个task"></a>前三个task</h6><p>15s &#x2F; 20s 准备，45s &#x2F; 1min 说，为准备<strong>时间很短</strong>，所以在记笔记的时候只写要说的几个 reason 中 <strong>key points</strong></p><p>模板：</p><p>*Yes &#x2F; no, I do &#x2F; don’t believe that … &#x2F;&#x2F; My preference for … is that …*（重复题干，语速<strong>慢一些</strong>，声音<strong>大一些，语调自信</strong>很重要）</p><p><em>and my reasons are listed as follows.</em></p><ul><li><p><em>The first reason is that … In addition, … Finally I want to emphasize that …</em> <em>Consequently</em> … 重复题目，有时间讲没时间拉倒。</p></li><li><p><em>For one thing, … For another … Also it should be noted that …</em> ( In conclusion … )</p></li></ul><p>如何避免卡壳：忌说 eh &#x2F; ah &#x2F; wu &#x2F; en，用 <strong>yeah, well, like, you know, say</strong>, 补充自己观点用 <strong>which inferred&#x2F; indicates (the idea that), namely…, In fact what I want to emphasize is…</strong> 。</p><h6 id="最后一个task"><a href="#最后一个task" class="headerlink" title="最后一个task"></a>最后一个task</h6><p>概括 lecture &#x2F; class，注意下多记点笔记，到时候对着笔记读就好。</p><p>模板：</p><p><em>The lecturer &#x2F; author came up with the idea that … \ concept of … He &#x2F; she first mentioned the significance &#x2F; phenomenon ( from which he &#x2F; she concluded … ) … Later he &#x2F; she claimed that … In addition &#x2F; However, … he &#x2F; she added &#x2F; raised a question ( 质疑 ) In conclusion, all of the above contributes to the lecturer &#x2F; author’s idea of …</em></p><p>For quotation: <em>The lecturer &#x2F; author mentioned in his lecture &#x2F; text that … &#x2F;&#x2F; He &#x2F; she made a very good point such that …</em></p><p>注：这个模板也可以用于 <strong>integrated writing</strong>。</p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p><strong>背单词</strong>，多读长难句保证文章看懂没压力。</p><p>考试别睡着。</p><h4 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h4><p>多刷题，大概有idea都会问些啥问题。</p><p>练速记笔记，记关键词和句子之间<strong>逻辑关系</strong>，用只要自己能看得懂的符号，<strong>中英结合</strong>。</p><h4 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h4><h6 id="Integrated-Writing"><a href="#Integrated-Writing" class="headerlink" title="Integrated Writing"></a>Integrated Writing</h6><p>见口语最后一个task。</p><h6 id="大作文"><a href="#大作文" class="headerlink" title="大作文"></a>大作文</h6><p>30 min，300+字，<strong>能多写尽量多写</strong>。</p><p>构思五分钟，记一下三个以上reason的key words ( 想不到点可以<strong>辩证</strong> )，马上开始码字。</p><p>千万<strong>不能有语法句法错误</strong>，不确定拼写的词换掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;浅聊&quot;&gt;&lt;a href=&quot;#浅聊&quot; class=&quot;headerlink&quot; title=&quot;浅聊&quot;&gt;&lt;/a&gt;浅聊&lt;/h4&gt;&lt;p&gt;客观评价来说，托福难度不高。考前刷过少许题目之后身边的小伙伴们都能做到阅读听力接近满分。那么，决定高分的部分是写作和口语。然而，写作和口语多</summary>
      
    
    
    
    <category term="Dailies" scheme="https://maizehsu.me/categories/Dailies/"/>
    
    
    <category term="托福" scheme="https://maizehsu.me/tags/%E6%89%98%E7%A6%8F/"/>
    
    <category term="申请" scheme="https://maizehsu.me/tags/%E7%94%B3%E8%AF%B7/"/>
    
    <category term="语言" scheme="https://maizehsu.me/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Hexo theme: Icarus | The Road To Personalization (1)</title>
    <link href="https://maizehsu.me/2022/08/15/Icarus-Configuration/"/>
    <id>https://maizehsu.me/2022/08/15/Icarus-Configuration/</id>
    <published>2022-08-15T10:14:34.579Z</published>
    <updated>2022-08-15T10:57:40.297Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列记录一下 personalize Icarus 主题的过程。之后打算写一个详细的 changelog，那么这个系列姑且先当作折腾过程中的随记吧。</p><h4 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h4><ul><li><a href="https://git-scm.com/">Git</a></li><li><a href="https://pages.github.com/">Github Pages</a></li><li><a href="https://nodejs.org/en/download/">node.js</a></li></ul><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 验证是否安装成功</span><br><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line">// 初始化文件夹</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">// 生成静态文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">// 打开本地服务器预览: localhost:4000/</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h4><p>修改 <code>_config.yml</code> 配置文件最后一段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Maizehsu/Maizehsu.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>安装插件 <code>npm i hexo-deployer-git</code> ，此时 <code>\source\_posts</code> 目录下放置 <code>.md</code> 文档。</p><p>三板斧更新 Blog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 生成静态文件</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">// 本地预览效果</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">// 部署到 github</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><h6 id="Logo"><a href="#Logo" class="headerlink" title="Logo"></a>Logo</h6><p>左上角和左下角导航栏图标修改在 <code>_config.icarus.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Path or URL to the website&#x27;s logo</span><br><span class="line">logo:</span><br><span class="line">    text: Maize&#x27;s Blog</span><br></pre></td></tr></table></figure><h6 id="Favicon-amp-Title"><a href="#Favicon-amp-Title" class="headerlink" title="Favicon &amp; Title"></a>Favicon &amp; Title</h6><p>favicon 修改在 <code>_config.icarus.yml</code> ，这里用了 <a href="https://favicon.io/favicon-generator/">favicon generator from text</a> ，字体用的是 <a href="https://fonts.google.com/specimen/Acme">Acme</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Page metadata configurations</span><br><span class="line">head:</span><br><span class="line">    # URL or path to the website&#x27;s icon</span><br><span class="line">    favicon: /img/favicon.ico</span><br></pre></td></tr></table></figure><p>首页 title 修改在 <code>_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Maize&#x27;s Blog</span><br></pre></td></tr></table></figure><p>同样地方顺便也可以修改一下 author</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">author: Maize_hsu</span><br></pre></td></tr></table></figure><p>首页三栏，阅读页两栏，把 Recents 和 Archives 放在右边栏，在阅读模式下放回左边。新建一个 <code>_config.post.yml</code> 覆盖之前的配置</p><h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>首先用 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 插件生成 <code>RSS</code> 源，再通过 follow.it 托管服务，具体教程请参照<a href="http://ppoffice.github.io/hexo-theme-icarus/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/#follow-it">这里</a></p><h4 id="Navbar"><a href="#Navbar" class="headerlink" title="Navbar"></a>Navbar</h4><p>暂时没改，未来需要增加更多顶部栏时候再配置。导航栏右侧 icon 对应的 github 链接改成了个人网站的 repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Links to be shown on the right of the navigation bar</span><br><span class="line">links:</span><br><span class="line">    Download on GitHub:</span><br><span class="line">        icon: fab fa-github</span><br><span class="line">        url: https://github.com/Maizehsu/Maizehsu.github.io</span><br></pre></td></tr></table></figure><h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><p>右下角 copyright 部分暂时没打算动</p><h4 id="Article-amp-search"><a href="#Article-amp-search" class="headerlink" title="Article &amp; search"></a>Article &amp; search</h4><p>代码高亮和搜索暂时没打算动</p><h4 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h4><p>Widget 是 Icarus 主题精髓部分，下面是具体配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">position: left</span><br><span class="line">type: profile</span><br><span class="line"># Author name</span><br><span class="line">author: Maize_hsu</span><br><span class="line"># Author title</span><br><span class="line">author_title: Undergrad of cs @umich &amp;&amp; ece @sjtu</span><br><span class="line"># Author&#x27;s current location</span><br><span class="line">location: Ann Arbor, MI</span><br><span class="line"># URL or path to the avatar image</span><br><span class="line">avatar: img/avatar.jpg</span><br><span class="line"># Whether show the rounded avatar image</span><br><span class="line">avatar_rounded: true</span><br><span class="line"># Email address for the Gravatar</span><br><span class="line">gravatar:</span><br><span class="line"># URL or path for the follow button</span><br><span class="line">follow_link: https://github.com/Maizehsu</span><br><span class="line"># Links to be shown on the bottom of the profile widget</span><br><span class="line">social_links:</span><br><span class="line">    Email:</span><br><span class="line">        icon: fas fa-envelope</span><br><span class="line">        url: mailto:maizehsu02@gmail.com</span><br><span class="line">    Github:</span><br><span class="line">        icon: fab fa-github</span><br><span class="line">        url: https://github.com/Maizehsu</span><br><span class="line">    # Twitter:</span><br><span class="line">    #     icon: fab fa-twitter</span><br><span class="line">    #     url: https://twitter.com</span><br><span class="line">    Linkedin:</span><br><span class="line">        icon: fab fa-linkedin</span><br><span class="line">        url: https://www.linkedin.com</span><br><span class="line">    CV: download/cv_mai_xu.pdf</span><br><span class="line">    douban: https://www.douban.com/people/199359961/</span><br><span class="line">    # Zhihu:</span><br><span class="line">    #     icon: fab fa-zhihu</span><br><span class="line">    #     url: https://www.zhihu.com/people/maize-hsu</span><br></pre></td></tr></table></figure><p>其中图标可以选择使用 <a href="https://fontawesome.com/start">font-awesome 库</a> ，也可以用文字形式，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;链接名称&gt;: &lt;链接的URL地址&gt;</span><br></pre></td></tr></table></figure><p>删掉了友链和推广板块</p><h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><p>评论系统用了 <code>gitalk</code> ，网上教程很多就不多赘述了，配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comment:</span><br><span class="line">    type: gitalk</span><br><span class="line">    client_id: xxxx</span><br><span class="line">    client_secret: xxxx</span><br><span class="line">    repo: gitalk</span><br><span class="line">    owner: Maizehsu</span><br><span class="line">    admin: Maizehsu</span><br></pre></td></tr></table></figure><h4 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h4><p>Google Analytics，网上教程很多，这里也不赘述了</p><h4 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h4><p>在 markdown 环境下渲染数学公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><h4 id="https-加密"><a href="#https-加密" class="headerlink" title="https 加密"></a>https 加密</h4><p>参考了这两个链接配置自定义域名和 Github Page 之间的联系：</p><ul><li><a href="https://github.com/orgs/community/discussions/22052">https://github.com/orgs/community/discussions/22052</a></li><li><a href="https://stackoverflow.com/questions/54059217/how-to-fix-domain-does-not-resolve-to-the-github-pages-server-error-in-github">https://stackoverflow.com/questions/54059217/how-to-fix-domain-does-not-resolve-to-the-github-pages-server-error-in-github</a></li></ul><p>对于我用的 <a href="https://www.namecheap.com/support/knowledgebase/article.aspx/9645/2208/how-do-i-link-my-domain-to-github-pages/">namecheap.com</a> 来说，</p><blockquote><p>Here you will need to create several records for your domain:</p><ul><li>A record for <strong>@</strong> pointing to <em>185.199.108.153</em></li><li>A record for <strong>@</strong> pointing to <em>185.199.109.153</em></li><li>A record for <strong>@</strong> pointing to <em>185.199.110.153</em></li><li>A record for <strong>@</strong> pointing to <em>185.199.111.153</em></li><li>CNAME record for <strong>www</strong> pointing to your <em><a href="http://username.github.io/">username.github.io</a></em> (the username should be replaced with your actual GitHub account username):</li></ul></blockquote><p>配置完记得</p><blockquote><p>Just make sure you wait for the DNS Propagation to take effect which in some cases might take up to 24hrs.</p><p>WAIT A DAY, ENJOY OUTDOOR WALK.</p></blockquote><p>真的很喜欢 stack overflow 上的一些幽默。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个系列记录一下 personalize Icarus 主题的过程。之后打算写一个详细的 changelog，那么这个系列姑且先当作折腾过程中的随记吧。&lt;/p&gt;
&lt;h4 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Tech" scheme="https://maizehsu.me/categories/Tech/"/>
    
    
    <category term="Icarus" scheme="https://maizehsu.me/tags/Icarus/"/>
    
    <category term="Config" scheme="https://maizehsu.me/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>绝佳的旅游电影：Ground Control to Major Tom</title>
    <link href="https://maizehsu.me/2022/08/15/%E5%BD%B1%E8%AF%84%EF%BC%9A%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/"/>
    <id>https://maizehsu.me/2022/08/15/%E5%BD%B1%E8%AF%84%EF%BC%9A%E7%99%BD%E6%97%A5%E6%A2%A6%E6%83%B3%E5%AE%B6/</id>
    <published>2022-08-15T09:34:55.890Z</published>
    <updated>2022-08-15T10:07:16.130Z</updated>
    
    <content type="html"><![CDATA[<p>今天和朋友奔着轻松愉快的目标，在机缘巧合下受标题吸引，选了这部轻喜剧电影。没想到，电影内核和最近反复思考咀嚼的一些想法很是相似，不得不说是意外之中的惊喜。</p><p>电影前半段节奏慢了些，男主的想象支撑起了大多数情节和笑点。在中段介绍男主父亲去世的时候，终于读出了<strong>作品主题：Live a Life</strong>。父亲从小给男主做发型，带男主玩 cool stuff，代表男主内心 adventurous，passionate 的一面。父亲的去世两天后，Walter 剪了头，去披萨店找了份 ordinary job，从此封闭自己做白日梦，一 ordinary，便 ordinary 到了中年。之后 Walter 走遍世界（旅游电影上线，北欧部分都是实拍哦），卖掉象征对父亲去世执念的老钢琴，鼓起勇气对自己心爱的姑娘 open up，登上杂志封面，明白人生之精彩在于大胆追逐，用力生活。</p><p>Walter 在电影中是多么幸运：拥有一个 supportive family，母亲注重大局，能够独立照顾自己不拖累子女，妹妹有理想抱负，关心，用热情感染哥哥；拥有说走就走的能力（一本丑国护照）；自己心爱的妹子愿意包容他，等他觉醒，找寻自我，还在 Walter 不敢搭讪的时候主动约他，找话题；实在是大幸。三者任其一，对于我们普通人来说大抵都称得上是毕生难求。<strong>有这样的环境和前提条件，才有自由追逐人生 passion and meaning 的资本。</strong>因此，这样的美式鸡汤价值观固然 hopeful，但想想就行了。</p><p>真正驱使 Walter 改变心态 not to be ordinary 的 moment 是在他在最后一刻决定登上了去冰岛的飞机。临上飞机前，Walter 想象女主唱了 David Bowie 的 <em>Space Oddity</em>，原片保留了火箭起飞的 whispering 倒计时，当原曲火箭喷发的声音和直升机螺旋桨旋转起飞的声音重合，</p><blockquote><p>Ground Control to Major Tom (ten, nine, eight, seven, six)</p><p>Commencing countdown, engines on (five, four, three)</p><p>Check ignition and may God’s love be with you (two, one, liftoff)</p></blockquote><p>当原曲唱到 Major Tom 踏出舱门，拥抱宇宙，和直升机飞越丹麦海峡，背景冰山小镇的美景交相辉映，</p><blockquote><p>I’m stepping through the door</p><p>And I’m floating in a most peculiar way</p><p>And the stars look very different today</p></blockquote><p>不可谓是不震撼。</p><p>不过现实中，Major Tom 并非和女主鼓励男主时所说的，是励志角色。在 <em>Space Oddity</em> 的最后，Major Tom 和 Ground Control 失去联系，独自飘向宇宙。而这个 character 在 David Bowie 的另一首歌 <em>Ashes to Ashes</em> 中被鉴定为 junkie，大抵这几首歌都有隐喻 drug abuse 的意思，不过那都是后话了。说不定女主也知道，只是人家真的对 Walter 好，才 tell a white lie 呢。</p><p>看完电影和朋友聊了许久最近的困惑，为什么坚持离开自己的舒适圈，走出去看看这世界。仔细思考了下，原因其中之一得是，奢望在拥抱世界，体验多元，尝试包容的过程中，更加了解自己，过些自己想要的生活，进而 pursue some happiness。回首一路，从小到大在国内最优秀的学校长大，毒害自己最多的是内卷和竞争的心态和名校情结。若想 let go，inevitably 需要踏出这一步。朋友给予的临别礼物上赠言 “Live Big”，意在祝福我在全新环境下逐梦成功。<strong>我也希望她能够 stop living an ordinary life, stop following the given path，相信自己，勇敢的踏出这一步。</strong></p><p>电影中 <em>Space Oddity</em> 插曲结束前，飞行员对 Walter 说 “*Hey, I’m glad you came.*” 希望若干年后的自己回首此时此刻，也能对自己说出一样的话，感谢现在的自己做出看看这世界的决定。</p><p><strong>Live Big, Live Happy, Live a Life。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天和朋友奔着轻松愉快的目标，在机缘巧合下受标题吸引，选了这部轻喜剧电影。没想到，电影内核和最近反复思考咀嚼的一些想法很是相似，不得不说是意外之中的惊喜。&lt;/p&gt;
&lt;p&gt;电影前半段节奏慢了些，男主的想象支撑起了大多数情节和笑点。在中段介绍男主父亲去世的时候，终于读出了&lt;st</summary>
      
    
    
    
    <category term="Reviews" scheme="https://maizehsu.me/categories/Reviews/"/>
    
    
    <category term="随想" scheme="https://maizehsu.me/tags/%E9%9A%8F%E6%83%B3/"/>
    
    <category term="影评true" scheme="https://maizehsu.me/tags/%E5%BD%B1%E8%AF%84true/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 刷题笔记：Cpp STL总结自用</title>
    <link href="https://maizehsu.me/2022/08/15/STL/"/>
    <id>https://maizehsu.me/2022/08/15/STL/</id>
    <published>2022-08-15T06:47:22.564Z</published>
    <updated>2022-08-15T10:12:42.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝。另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了 vector 的效率；</li><li>对头部和中间进行插入删除元素操作需要移动内存，如果你的元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高；</li><li>对最后元素操作最快（在后面插入删除元素最快），此时一般不需要移动内存，只有保留内存不够时才需要。</li></ul></li><li><p>优点：支持随机访问，查询效率高。</p></li><li><p>缺点：当向其头部或中部插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入的效率比较低。</p></li><li><p>适用场景：适用于对象简单，变化较小，并且频繁随机访问的场景。</p></li><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj中含有obj_num个obj_init_value为值的type</span></span><br><span class="line">vector&lt;type&gt;<span class="built_in">obj</span>(obj_num, obj_init_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj1为obj2的复制</span></span><br><span class="line">vertor&lt;type&gt;<span class="built_in">obj1</span>(obj2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj1为obj2的前三个元素复制</span></span><br><span class="line">vector&lt;type&gt;<span class="built_in">obj1</span>(obj2.<span class="built_in">begin</span>(), obj2.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中获得初值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">obj</span><span class="params">(a, a+<span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>push_back(elem), pop_back() 实现在容器最后添加 &#x2F; 删除元素，顺序读取，迭代器读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push_back(elem) 在数组最后添加数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 去掉数组最后一个数据</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it=obj.<span class="built_in">begin</span>(); it!=obj.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">       obj.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第一个元素前面插入5</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = obj.<span class="built_in">begin</span>();</span><br><span class="line">obj.<span class="built_in">insert</span>(it, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>clear() 清除所有数据，empty() 判断是否为空</p></li><li><p>obj.front() 和 obj.back() 返回第一项和最后一项</p></li><li><p>begin() 得到数组头的指针，end() 得到数组的最后一个单元 + 1 的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(obj.<span class="built_in">begin</span>(), obj.<span class="built_in">end</span>()); <span class="comment">//从小到大</span></span><br><span class="line">    <span class="built_in">reverse</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>()); <span class="comment">//从大到小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找10，若存在返回其在向量中的位置，需要include&lt;algorithm&gt;</span></span><br><span class="line"> <span class="built_in">find</span>(obj.<span class="built_in">begin</span>(), obj.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>deque 允许使用常数项时间对头端进行元素的插入和删除操作；</li><li>deque 没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留（reserve）功能。虽然deque 容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针， 其复杂度和 vector不是一个量级，这当然影响各个运算的层面；</li><li>除非有必要，我们应该尽可能的使用 vector，而不是 deque。对 deque 进行的排序操作，为了最高效率，可将 deque 先完整的复制到一个 vector 中，对 vector 容器进行排序，再复制回 deque。</li></ul></li><li><p>优点：支持随机访问，查询效率高；可在两端进行push、pop。</p></li><li><p>缺点：不适合中间插入删除操作；占用内存高。</p></li><li><p>适用场景：只有需要在首端进行插入&#x2F;删除操作的时候，还要兼顾随机访问效率，才选择deque，否则都选择vector。</p></li><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造形式</span></span><br><span class="line">deque&lt;T&gt; deqT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);</span><br></pre></td></tr></table></figure></li><li><p>其他函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则删除末尾超出容器长度的元素</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem);</span><br></pre></td></tr></table></figure></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存；</li><li>在哪里添加删除元素性能都很高，不需要移动内存，当然也不需要对每个元素都进行构造与析构了，所以常用来做随机插入和删除操作容器；</li><li>访问开始和最后两个元素最快，其他元素的访问时间一样。</li></ul></li><li><p>优点：内存不连续，动态操作，可在任意位置插入或删除且效率高。</p></li><li><p>缺点：不支持随机访问。</p></li><li><p>适用场景：经常进行插入和删除操作并且不经常随机访问的场景。</p></li><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含 n 个元素的 list 容器，并为每个元素指定初始值</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在已有 list 容器的情况下，通过拷贝该容器可以创建新的 list 容器</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过拷贝其他类型容器（或者普通数组）中指定区域内的元素，可以创建新的 list 容器</span></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>删除特定位置元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val.<span class="built_in">erase</span>(pos);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>set 中的元素都是排好序的，集合中没有重复的元素;</li><li>map 和 set 的插入删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。</li></ul></li><li><p>优点：使用平衡二叉树实现，便于元素查找，且保持了元素的唯一性，以及能自动排序。</p></li><li><p>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。</p></li><li><p>适用场景：适用于经常查找一个元素是否在某群集中且需要排序的场景。</p></li><li><p>特点 1：不重复，自动排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setT;</span><br><span class="line"></span><br><span class="line">setT.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setT.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setT.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">setT.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点 2：关联性容器，键值对默认1，2，3</p></li><li><p>multiset 可以包含重复元素</p></li><li><p>unordered_set 用哈希表存储，无序但查找快</p></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>特点：</p><ul><li>自动建立 Key - value 的对应。key 和 value 可以是任意你需要的类型；</li><li>根据 key 值快速查找记录，查找的复杂度基本是 O ( log N )，如果有 1000 个记录，二分查找最多查找 10次；</li><li>增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响；</li><li>对于迭代器来说，可以修改实值，而不能修改 key。</li></ul></li><li><p>优点：使用平衡二叉树实现，便于元素查找，且保持了元素的唯一性，可以创建字典；</p></li><li><p>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。</p></li><li><p>适用场景：适用于需要存储一个数据字典，并要求方便地根据 key 找 value 的场景。</p></li><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个键值对</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前进行初始化</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>), std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h4><ul><li>特点<ul><li>vector 头部与中间插入和删除效率较低，在尾部插入和删除效率高，支持随机访问；</li><li>deque 是在头部和尾部插入和删除效率较高，支持随机访问，但效率没有 vector 高；</li><li>list 在任意位置的插入和删除效率都较高，但不支持随机访问；</li><li>set 由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高；</li><li>map 可以自动建立 Key - value 的对应，key 和 value 可以是任意你需要的类型，根据 key 快速查找记录。</li></ul></li><li>适用场景<ul><li>如果需要高效的随机存取，不在乎插入和删除的效率，使用 vector；</li><li>如果需要大量的插入和删除元素，不关心随机存取的效率，使用 list；</li><li>如果需要随机存取，并且关心两端数据的插入和删除效率，使用 deque；</li><li>如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap；</li><li>如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。</li></ul></li><li>时间复杂度<ul><li>vector 在头部和中间位置插入和删除的时间复杂度为 O ( N ) ，在尾部插入和删除的时间复杂度为 O ( 1 ) ，查找的时间复杂度为 O ( 1 ) ；</li><li>deque 在中间位置插入和删除的时间复杂度为 O ( N ) ，在头部和尾部插入和删除的时间复杂度为 O ( 1 ) ，查找的时间复杂度为 O ( 1 ) ；</li><li>list 在任意位置插入和删除的时间复杂度都为 O ( 1 ) ，查找的时间复杂度为 O ( N ) ；</li><li>set 和 map 都是通过红黑树实现，因此插入、删除和查找操作的时间复杂度都是 O ( log N ) 。</li></ul></li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><blockquote><p>[1]. <a href="https://zhuanlan.zhihu.com/p/130905242">https://zhuanlan.zhihu.com/p/130905242</a></p><p>[2]. <a href="https://blog.51cto.com/u_15452541/4955600">https://blog.51cto.com/u_15452541/4955600</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Vector&quot;&gt;&lt;a href=&quot;#Vector&quot; class=&quot;headerlink&quot; title=&quot;Vector&quot;&gt;&lt;/a&gt;Vector&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="Tech" scheme="https://maizehsu.me/categories/Tech/"/>
    
    
    <category term="Leetcode" scheme="https://maizehsu.me/tags/Leetcode/"/>
    
    <category term="秋招" scheme="https://maizehsu.me/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>The Start of Everything</title>
    <link href="https://maizehsu.me/2022/08/15/Start/"/>
    <id>https://maizehsu.me/2022/08/15/Start/</id>
    <published>2022-08-15T03:39:20.722Z</published>
    <updated>2022-08-15T06:37:26.628Z</updated>
    
    
    
    
    <category term="Dailies" scheme="https://maizehsu.me/categories/Dailies/"/>
    
    
    <category term="随想" scheme="https://maizehsu.me/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
